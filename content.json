{"meta":{"title":"Leo's Home","subtitle":"Android Developer","description":"On My Way","author":"Leo","url":"http://lijianqiang12.com"},"pages":[{"title":"分类","date":"2016-07-29T23:08:30.000Z","updated":"2016-07-29T23:08:30.000Z","comments":true,"path":"categories/index.html","permalink":"http://lijianqiang12.com/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2016-08-03T10:59:10.000Z","updated":"2016-08-03T10:59:10.000Z","comments":true,"path":"about/index.html","permalink":"http://lijianqiang12.com/about/index.html","excerpt":"","text":"联系方式:lijianqiang12@gmail.com"},{"title":"标签","date":"2016-07-29T23:08:41.000Z","updated":"2016-07-29T23:08:41.000Z","comments":true,"path":"tags/index.html","permalink":"http://lijianqiang12.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"一个APP的诞生记录","slug":"create-app","date":"2016-09-07T11:34:16.000Z","updated":"2016-09-07T13:32:13.000Z","comments":true,"path":"2016/09/07/create-app/","link":"","permalink":"http://lijianqiang12.com/2016/09/07/create-app/","excerpt":"前言很久以前就想写一个APP，原本想的是做一个手机版的zillions of games，然而在开工不久手游上架就需要广电的审核了，思考再三，觉得不能上架的APP即便写出来也只能作为一个Demo，没有多大意义，最近又有了新的想法，做一款吐槽类软件，目标群体为心有怨气无处发泄的人，在这里吐槽的人名字会被以首字母缩写代替，吐槽对象会被归类，大家可以找到拥有同样吐槽目标的“朋友”，有共同敌人的人就能成为朋友嘛，只是为了好玩，并无野心，希望做的过程中能够给自己带来收获，也给用的人带来快乐。","text":"前言很久以前就想写一个APP，原本想的是做一个手机版的zillions of games，然而在开工不久手游上架就需要广电的审核了，思考再三，觉得不能上架的APP即便写出来也只能作为一个Demo，没有多大意义，最近又有了新的想法，做一款吐槽类软件，目标群体为心有怨气无处发泄的人，在这里吐槽的人名字会被以首字母缩写代替，吐槽对象会被归类，大家可以找到拥有同样吐槽目标的“朋友”，有共同敌人的人就能成为朋友嘛，只是为了好玩，并无野心，希望做的过程中能够给自己带来收获，也给用的人带来快乐。 功能点 微信登录 QQ登录（由于短信注册登录不稳定或价格高，因此不采用，而邮箱注册过于繁琐，也不采用） 修改头像及昵称（为了隐藏信息） 发布自己的吐槽 评论别人的吐槽及回复别人的评论 为吐槽添加种类（人，公司，地区，其它） 私信 关注其他用户 举报 根据距离、热度排序 根据地域、公司、人名缩写搜索 被点开次数统计及评论数量统计 原型原型我打算用墨刀来开发，简单方便，易用，不会在这一环节浪费太多时间","categories":[{"name":"android","slug":"android","permalink":"http://lijianqiang12.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://lijianqiang12.com/tags/android/"}]},{"title":"Android studio快捷键(Mac版)","slug":"Android-studio快捷键-Mac版","date":"2016-08-22T13:27:41.000Z","updated":"2016-08-23T14:56:21.000Z","comments":true,"path":"2016/08/22/Android-studio快捷键-Mac版/","link":"","permalink":"http://lijianqiang12.com/2016/08/22/Android-studio快捷键-Mac版/","excerpt":"快捷键才是提高效率的一大杀器，一劳永逸，打算长期使用Android studio的话，还是记下来吧！","text":"快捷键才是提高效率的一大杀器，一劳永逸，打算长期使用Android studio的话，还是记下来吧！ 快捷键 功能 CMD + F7 在当前文件中查找使用 Cmd + F12 文件方法结构 CMD + 1 打开或者关闭Project侧边栏 Cmd + Plus,Minus 折叠展开代码块 Cmd + Delete 删除行 Cmd + E 快捷最近打开 Cmd + R 查找+替换 CMD + R 打开当前类的父类中的方法 Cmd + P 提示参数类型 Cmd + D 快捷向下复制行 Cmd + F 查找 Cmd + G 代码高亮向下查找 Cmd + J 按照模板生成代码 Cmd + / 注释代码(//) Cmd + Space 快速查找定义 Cmd + Left/Right 快捷定位到行首/尾 ——– —— Cmd + Shift + F7 代码高亮 Cmd + Shift + Plus,Minus 折叠展开全部代码块 Cmd + Shift + U 大小写转换 Cmd + Shift + A 查找动作 Cmd + Shift + G 代码高亮向上查找 Cmd + Shift + Enter 完成声明, 如果最后没有分号, 添加分号, 如果有分号, 则换行 ——– —— Cmd + Alt + L 格式化代码 Cmd + Alt + / 注释代码(/**/) ——– —— CMD + fn + Left/Right 移动到编辑框的第一行和最后一行 ——– —— Ctrl + O 快捷覆写方法 Ctrl + P 查看方法参数 Ctrl + H 查看类继承关系 Ctrl + Space 自动完成代码 Ctrl + Up/Down 快捷移动 ——– —— Ctrl + Shift + J 快捷退至上一行末尾，取消换行 Ctrl + Shift + Space 智能自动完成代码 ——– —— Ctrl + Alt + O 清除无效引用 Ctrl + Alt + H 查找调用的位置 ——– —— F3 添加书签 Alt + F1 快捷选择 Alt + F3 添加书签标识 Alt + F7 查找使用(Find usages) Alt + Enter 提示错误解决方案 Alt + Up/Down 扩大缩小选中范围 ——– —— Alt + Shift + Up/Down 上下移动代码 ——– —— Shift + Shift(Double Shift) 全局搜索，整个项目范围内搜索任何文件或者字串","categories":[{"name":"工具","slug":"工具","permalink":"http://lijianqiang12.com/categories/工具/"}],"tags":[{"name":"Android studio","slug":"Android-studio","permalink":"http://lijianqiang12.com/tags/Android-studio/"}]},{"title":"coding pages ip被墙","slug":"coding-pages-ip被墙","date":"2016-08-19T12:17:52.000Z","updated":"2016-08-19T13:17:59.000Z","comments":true,"path":"2016/08/19/coding-pages-ip被墙/","link":"","permalink":"http://lijianqiang12.com/2016/08/19/coding-pages-ip被墙/","excerpt":"这是一个令人悲伤的故事","text":"这是一个令人悲伤的故事 最近自己的博客总是间歇性抽风，偶尔会打不开，登录git coding的时候也偶尔会有连接不上服务器的提示，在多尝试几次登录后，又能git coding又可以成功连接，博客也能成功连接，于是以为可能是git coding服务器不是很稳定（用的双线，国外访问github pages，国内访问git coding），然而事情并非我想的那样 今天在我又一次尝试打开博客的时候，又像往常一样，打不开，于是我尝试打开git coding，很流畅，恩？？？纳尼，ping了一下博客域名，不通，ping了一下博客的ip，不通，打开网址’lijianqiang12.coding.me’，打开了 上网google了一下，基本可以确定是被墙了，让我不理解的是，我的网站上只有几篇无伤大雅的博客，没有黄赌毒，为什么要墙我，让我浪费那么多时间做这些没有意义的事情，看了知乎上如何评价手游需要广电审核问题下有个回答 不能给人带来不便的权力不是真的权力 在网上找了一些方法，最后决定’将dnspod解析中解析到ip改为解析到域名’ 然后进入漫长的等待… 一个小时过去，现在已经又能访问了","categories":[{"name":"博客","slug":"博客","permalink":"http://lijianqiang12.com/categories/博客/"}],"tags":[{"name":"against GFW","slug":"against-GFW","permalink":"http://lijianqiang12.com/tags/against-GFW/"}]},{"title":"RxJava","slug":"RxJava","date":"2016-07-27T13:57:43.000Z","updated":"2016-08-23T10:35:36.000Z","comments":true,"path":"2016/07/27/RxJava/","link":"","permalink":"http://lijianqiang12.com/2016/07/27/RxJava/","excerpt":"RxJava使用方法使用步骤 导入jcenter 12compile 'io.reactivex:rxjava:1.0.14'compile 'io.reactivex:rxandroid:1.0.1'","text":"RxJava使用方法使用步骤 导入jcenter 12compile 'io.reactivex:rxjava:1.0.14'compile 'io.reactivex:rxandroid:1.0.1' 创建观察者Observer对象 12345678910111213141516 Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onNext(String s)&#123; Log.d(tag,\"Item: \"+s); &#125; @Override public void onCompleted()&#123; Log.d(tag,\"Completed!\"); &#125; @Override public void onError(Throwablee)&#123; Log.d(tag,\"Error!\"); &#125;&#125;; Subscriber是Observer的扩展，比Observer多onStart()法，会在subscribe刚开始而事件未发送时调用，但不适用于显示progressbar，因为它总在subscribe发生的线程被调用，不能指定线程，若想指定线程，需要用 doOnSubscribe()。 Subscription是实现了Subscriber的一个接口，其方法unsubscribe用于取消前订阅状态，调用后，Subsrciber不再接收事件，调用前最好用isUnsubscribed()断，因为在 subscribe() 之后， Observable 会持有 Subscriber 的引用，因此尽快在合适的地方（例如 onPause() onStop() 等方法中）调用unsubscribe释放，避免内存泄漏。 创建被观察者 123456789101112131415Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(\"Hello\"); subscriber.onNext(\"Hi\"); subscriber.onNext(\"Aloha\"); subscriber.onCompleted(); &#125;&#125;);//与上面的写法等价//或Observable observable = Observable.just(\"Hello\", \"Hi\", \"Aloha\");//或String[] words = &#123;\"Hello\", \"Hi\", \"Aloha\"&#125;;Observable observable = Observable.from(words); 订阅 123observable.subscribe(observer);// 或者：observable.subscribe(subscriber); 除了 subscribe(Observer) 和 subscribe(Subscriber) ，subscribe() 还支持不完整定义的回调，RxJava 会自动根据定义创建出 Subscriber 。形式如下： 12345678910111213141516171819202122232425262728 Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; // onNext() @Override public void call(String s) &#123; Log.d(tag, s); &#125; &#125;; Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() &#123; // onError() @Override public void call(Throwable throwable) &#123; // Error handling &#125; &#125;; Action0 onCompletedAction = new Action0() &#123; // onCompleted() @Override public void call() &#123; Log.d(tag, \"completed\"); &#125; &#125;; // 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext() observable.subscribe(onNextAction); // 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError() observable.subscribe(onNextAction, onErrorAction);// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted() observable.subscribe(onNextAction, onErrorAction, onCompletedAction); 线程控制——Scheduler Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。 123456789Observable.just(1, 2, 3, 4) .subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程 .observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程 .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; Log.d(tag, \"number:\" + number); &#125; &#125;); 加载图片示例： 123456789101112131415161718192021222324252627int drawableRes = ...;ImageView imageView = ...;Observable.create(new OnSubscribe&lt;Drawable&gt;() &#123; @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123; Drawable drawable = getTheme().getDrawable(drawableRes)); subscriber.onNext(drawable); subscriber.onCompleted(); &#125;&#125;).subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程.observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程.subscribe(new Observer&lt;Drawable&gt;() &#123; @Override public void onNext(Drawable drawable) &#123; imageView.setImageDrawable(drawable); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(activity, \"Error!\", Toast.LENGTH_SHORT).show(); &#125;&#125;); 变换 所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。 map() 12345678910111213Observable.just(\"images/logo.png\") // 输入类型 String .map(new Func1&lt;String, Bitmap&gt;() &#123; @Override public Bitmap call(String filePath) &#123; // 参数类型 String return getBitmapFromPath(filePath); // 返回类型 Bitmap &#125; &#125;) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; // 参数类型 Bitmap showBitmap(bitmap); &#125; &#125;); 如上面这段代码，它的作用是将String事件转化为Bitmap事件。 flatmap()首先看一段代码 12345678910111213141516Student[] students = ...;Subscriber&lt;Course&gt; subscriber = new Subscriber&lt;Course&gt;() &#123; @Override public void onNext(Course course) &#123; Log.d(tag, course.getName()); &#125; ...&#125;;Observable.from(students) .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123; @Override public Observable&lt;Course&gt; call(Student student) &#123; return Observable.from(student.getCourses()); &#125; &#125;) .subscribe(subscriber); 从上面的代码可以看出，`flatMap()` 和 `map()` 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 `map()` 不同的是， `flatMap()` 中返回的是个 `Observable` 对象，并且这个 `Observable` 对象并不是被直接发送到了 `Subscriber` 的回调方法中。 `flatMap()` 的原理是这样的： a. 使用传入的事件对象创建一个 `Observable` 对象； b. 并不发送这个 `Observable`, 而是将它激活，于是它开始发送事件； c. 每一个创建出来的 `Observable` 发送的事件，都被汇入同一个 `Observable` ，而这个 `Observable` 负责将这些事件统一交给 `Subscriber` 的回调方法。这三个步骤，把事件拆成了两级，通过一组新创建的 `Observable` 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 `flatMap()` 所谓的 flat。 扩展：由于可以在嵌套的 `Observable` 中添加异步代码， `flatMap()` 也常用于嵌套的异步操作，例如嵌套的网络请求。示例代码（Retrofit + RxJava）： 123456789101112131415networkClient.token() // 返回 Observable&lt;String&gt;，在订阅时请求 token，并在响应后发送 token.flatMap(new Func1&lt;String, Observable&lt;Messages&gt;&gt;() &#123; @Override public Observable&lt;Messages&gt; call(String token) &#123; // 返回 Observable&lt;Messages&gt;，在订阅时请求消息列表，并在响应后发送请求到的消息列表 return networkClient.messages(); &#125;&#125;).subscribe(new Action1&lt;Messages&gt;() &#123; @Override public void call(Messages messages) &#123; // 处理显示消息列表 showMessages(messages); &#125;&#125;); 传统的嵌套请求需要使用嵌套的 `Callback` 来实现。而通过 `flatMap()` ，可以把嵌套的请求写在一条链中，从而保持程序逻辑的清晰。 `throttleFirst()`: 在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤，例如按钮的点击监听器： 123RxView.clickEvents(button) // RxBinding 代码，后面的文章有释 .throttleFirst(500, TimeUnit.MILLISECONDS) // 设置防抖间隔为500ms.subscribe(subscriber); 妈妈再也不怕我的用户手抖点开两个重复的界面啦。 compose() 用于包裹多次变换 12345678910111213141516public class LiftAllTransformer implements Observable.Transformer&lt;Integer, String&gt; &#123; @Override public Observable&lt;String&gt; call(Observable&lt;Integer&gt; observable) &#123; return observable .lift1() .lift2() .lift3() .lift4(); &#125;&#125;...Transformer liftAll = new LiftAllTransformer();observable1.compose(liftAll).subscribe(subscriber1);observable2.compose(liftAll).subscribe(subscriber2);observable3.compose(liftAll).subscribe(subscriber3);observable4.compose(liftAll).subscribe(subscriber4); 多次线程切换 12345678Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定 .subscribeOn(Schedulers.io()) .observeOn(Schedulers.newThread()) .map(mapOperator) // 新线程，由 observeOn() 指定 .observeOn(Schedulers.io()) .map(mapOperator2) // IO 线程，由 observeOn() 指定 .observeOn(AndroidSchedulers.mainThread) .subscribe(subscriber); // Android 主线程，由 observeOn() 指定 ![subsrcibeOn](/images/subsrcibeOn.jpg) ![observerOn](/images/observerOn.jpg) ![xiancheng](/images/xiancheng.jpg) 图中共有 5 处含有对事件的操作。由图中可以看出，①和②两处受第一个 `subscribeOn()` 影响，运行在红色线程；③和④处受第一个 `observeOn()` 的影响，运行在绿色线程；⑤处受第二个 `onserveOn()` 影响，运行在紫色线程；而第二个 `subscribeOn()` ，由于在通知过程中线程就被第一个 `subscribeOn()` 截断，因此对整个流程并没有任何影响。这里也就回答了前面的问题：当使用了多个 `subscribeOn()` 的时候，只有第一个 `subscribeOn()` 起作用。 然而，虽然超过一个的 `subscribeOn()` 对事件处理的流程没有影响，但在流程之前却是可以利用的。在前面讲 `Subscriber` 的时候，提到过 `Subscriber` 的 `onStart()` 可以用作流程开始前的初始化。然而`onStart()` 由于在 `subscribe()` 发生时就被调用了，因此不能指定线程，而是只能执行在 `subscribe()` 被调用时的线程。这就导致如果 `onStart()` 中含有对线程有要求的代码（例如在界面上显示一个 ProgressBar，这必须在主线程执行），将会有线程非法的风险，因为有时你无法预测 `subscribe()` 将会在什么线程执行。 而与 `Subscriber.onStart()` 相对应的，有一个方法 `Observable.doOnSubscribe()` 。它和 `Subscriber.onStart()` 同样是在 `subscribe()` 调用后而且在事件发送前执行，但区别在于它可以指定线程。默认情况下， `doOnSubscribe()` 执行在 `subscribe()` 发生的线程；而如果在 `doOnSubscribe()` 之后有 `subscribeOn()` 的话，它将执行在离它最近的 `subscribeOn()` 所指定的线程。 1234567891011Observable.create(onSubscribe).subscribeOn(Schedulers.io()).doOnSubscribe(new Action0() &#123; @Override public void call() &#123; progressBar.setVisibility(View.VISIBLE); // 需要在主线程执行 &#125;&#125;).subscribeOn(AndroidSchedulers.mainThread()) // 指定主线程.observeOn(AndroidSchedulers.mainThread()).subscribe(subscriber); 如上，在 doOnSubscribe()的后面跟一个 subscribeOn() ，就能指定准备工作的线程了。","categories":[{"name":"android","slug":"android","permalink":"http://lijianqiang12.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://lijianqiang12.com/tags/android/"}]},{"title":"nexus 6p root","slug":"nexus-6p-root","date":"2016-01-15T12:56:30.000Z","updated":"2016-08-15T12:06:45.000Z","comments":true,"path":"2016/01/15/nexus-6p-root/","link":"","permalink":"http://lijianqiang12.com/2016/01/15/nexus-6p-root/","excerpt":"&emsp;nexus 6p到货两天，感受了一下原生态android的魅力，然而作为一个开发者，不root是不行的，那么大家现在就跟我一起踏上root的旅程吧！","text":"&emsp;nexus 6p到货两天，感受了一下原生态android的魅力，然而作为一个开发者，不root是不行的，那么大家现在就跟我一起踏上root的旅程吧！ root: 解锁步骤：注意：执行完毕后会清除手机内存，请提前备份！！！ 1. 连接电脑，安装驱动与adb调试工具 2. 在命令行执行：adb reboot recovery 3. 当手机重启并进入recovery模式后执行：fastboot flashing unlock 刷入TWRP(确认当前系统为官方任意版本的镜像，如果不是，请自行刷入官方rom)1. 下载twrp，文章末尾我的网盘链接或者官方地址https://dl.twrp.me/angler/ 2. 在recovery模式下执行fastboot flash recovery twrp-2.8.7.2-angler.img（后面这个是你刚下载的的recovery名字） 用TWRP直接卡刷下面的SuperSU-2.6x以上版本（文章末尾我的百度云链接里有）1. 进入recovery模式下，按音量下键，看到recovery mode后，按关机键，进入recovery，第一次进入后会看到有一个确认界面，然后右滑底部滑块即可 2. 将手机插到电脑上，把刚才下载的SuperSU.zip放在手机里 3. 点install，找到SuperSU.zip，选择，然后把最下面滑块右滑，刷入 4. 刷完后TWRP会提示你“是否安装Supersu”，直接点“Do not Install”即可 反root:如果你不需要root了，可以直接卡刷这个root卸载脚本（或者需要更新SU的，也要先卡刷这个卸载脚本）UPDATE-unSU.zip 参考网址：http://www.mgyun.com:81/thread-48837-1-1.htmlhttp://m.anruan.com/view_16194.html 以上所有刷机包大家可到我的网盘下载http://pan.baidu.com/s/1kUcko2F","categories":[{"name":"刷机","slug":"刷机","permalink":"http://lijianqiang12.com/categories/刷机/"}],"tags":[{"name":"root","slug":"root","permalink":"http://lijianqiang12.com/tags/root/"}]},{"title":"小事","slug":"小事","date":"2015-12-14T06:25:13.000Z","updated":"2016-08-15T12:06:50.000Z","comments":true,"path":"2015/12/14/小事/","link":"","permalink":"http://lijianqiang12.com/2015/12/14/小事/","excerpt":"生活的小事，人生的大事。","text":"生活的小事，人生的大事。 &emsp;&emsp;看着姐姐日渐消瘦的身体和苍白的面色，心里很不是滋味，希望上天能够公平一些，让善良的人都能有一个好的结果，希望治疗能够顺利，希望姐姐能够快点好起来，姐姐的这场病提醒了我，必须要快点成长起来了，独当一面，我曾想过：如果不是姐姐得病，而是父母呢，我该怎么办？如果大家都不帮忙呢？如果我只能靠自己呢？如何获得巨额的医疗费用，如何照顾好他们？如何应对每一个突发状况？这些并没有答案，我唯独知道必须要有一个足够成功的事业去作为支撑来承受来自生活的每一次挑战，也只有事业可以带给我照顾家人的基础，如果可以，我还是希望自己能够以纯粹的热爱来对待自己的工作，然而越长大越知道那是多么的不易，能够保持一颗纯粹的心，是多么的幸运，你说是吗？","categories":[{"name":"生活日记","slug":"生活日记","permalink":"http://lijianqiang12.com/categories/生活日记/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://lijianqiang12.com/tags/生活/"},{"name":"日记","slug":"日记","permalink":"http://lijianqiang12.com/tags/日记/"}]},{"title":"Android开发艺术探索(三)——View事件","slug":"Android开发艺术探索-三-——View事件","date":"2015-12-12T15:38:04.000Z","updated":"2016-08-15T12:07:11.000Z","comments":true,"path":"2015/12/12/Android开发艺术探索-三-——View事件/","link":"","permalink":"http://lijianqiang12.com/2015/12/12/Android开发艺术探索-三-——View事件/","excerpt":"&emsp;&emsp;本篇将涉及到View的位置参数（left、right、top、buttom、x、y、translationX、translationY）、滑动（Scroller）速度（VelocityTracker）、手势（GestureDetector）、事件触发机制。","text":"&emsp;&emsp;本篇将涉及到View的位置参数（left、right、top、buttom、x、y、translationX、translationY）、滑动（Scroller）速度（VelocityTracker）、手势（GestureDetector）、事件触发机制。 View基础View与ViewGroup&emsp;&emsp;ViewGroup继承自View，因此View本身可以是单个控件也可以是一组控件，而ViewGroup内部又可以包含View或ViewGroup。 View的位置参数1234left = getLeft();right = getRight();top = getTop();buttom = getButtom(); View的位置坐标和父容器的关系 12x = left + translationX;y = top + translationY; x,y : View左上角的坐标 translationX,translationY : View左上角相对于父容器的偏移量 MotionEvent在手指接触屏幕所产生的一系列事件中，典型事件如下： ACTION_DOWN——手指刚接触屏幕 ACTION_MOVE——手指滑动 ACTION_UP——手指离开屏幕 TouchSlop系统所能识别出的最小滑动距离，获取方式如下： 1ViewConfiguration.get(getContext()).getScaledTouchSlop(); 源码中为8dp 速度追踪VelocityTracker用于追踪手指的滑动速度，使用方法如下： &emsp;1. 在View的onTouchEvent中追踪当前单击事件的速度 12VelocityTracker velocityTracker = VelocityTracker.obtain();velocityTracker.addMovement(event); &emsp;2. 当我们想知道当前的滑动速度时 123velocityTracker.copmuteCurrentVelocity(1000); //计算一秒之内的变化情况int xVelocity = (int) velocityTracker.getXVelocity(); //一秒之内X坐标的变化情况，从左向右为正int yVelocity = (int) velocityTracker.getYVelocity(); //一秒之内Y坐标的变化情况，从上向下为正 &emsp;3. 不用时重置并回收内存 12velocityTracker.clear();velocityTracker.recycler(); 手势GestureDetector检测手势，用于辅助检测用户的单击、滑动、长按、双击等行为，使用方式如下： &emsp;1. 创建GestureDetector对象并实现OnGestureListener和OnDoubleTapListener接口 1GestureDetector mGestureDetector = new GestureDetector(this); &emsp;2. 接管目标View的onTouchEvent方法，在View的onTouchEvent中添加： 12boolean consume = mGestureDetector.onTouchEvent(event);return consume; 方法介绍： 方法名 描述 所属接口 onDown 手指轻触屏幕的瞬间，由一个ACTION_DOWN触发 OnGestureListener onShowPress 手指轻触屏幕，尚未拖动，强调没有松开或拖动的状态（个人理解在onDown之后） OnGestureListener onSingleTapUp 单击，有可能是双击中的一次 OnGestureListener onScroll 手指按下并拖动 OnGestureListener onLongPress 长按 OnGestureListener onFling 按下屏幕快速滑动后松开 OnGestureListener onDoubleTap 双击，由两次单击组成，不能与onSingleTapConfirmed共存 OnDoubleTapListener onSingleTapConfirmed 严格的单击行为，不可能是双击中的一次 OnDoubleTapListener onDoubleTapEvent 双击，在双击期间，ACTION_UP、ACTION_MOVE、ACTION_DOWN都会触发此回调 OnDoubleTapListener 弹性滑动ScrollerscrollTo和scrollBy过程是瞬间完成的，某些情况下用户体验并不好，而利用Scroller可以实现弹性滑动，使用方法如下： 在继承View的类中： 1234567891011121314151617Scroller mScroller = new Scroller(mContext);//缓慢滑动到指定位置private void smoothScrollTo(int destX, int destY) &#123;trueint scrollX = getScrollX();trueint delta = destX - scrollX;truemScroller.startScroll(scrollX, 0, delta, 0, 1000); //1s内缓慢滑动到destXtrueinvalidate();&#125;@Overridepublic void computeScroll()&#123;trueif (mScroller.computeScrollOffset()) &#123;truetruescrollTo(mScroller.getCurrX(), mScroller.getCurrY());truetruepostInvalidate();true&#125;&#125;","categories":[{"name":"android","slug":"android","permalink":"http://lijianqiang12.com/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://lijianqiang12.com/tags/android/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://lijianqiang12.com/tags/读书笔记/"}]}]}